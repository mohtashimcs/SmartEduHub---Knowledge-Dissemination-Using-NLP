import { ViewPlugin, EditorView } from '@codemirror/view';
export type Events<K extends keyof HTMLElementEventMap> = Record<K, (this: HTMLElement, event: HTMLElementEventMap[K]) => void>;
interface DOMElementProps extends Partial<HTMLElement> {
}
type Options<T extends keyof HTMLElementEventMap> = {
    /**
     * Bind events on different dom nodes.
     * - `scroll` The DOM element that wraps the entire editor view.
     * - `dom` The DOM element that can be styled to scroll. (Note that it may not have been, so you can't assume this is scrollable.)
     * - `content` The editable DOM element holding the editor content. You should not, usually, interact with this content directly though the DOM, since the editor will immediately undo most of the changes you make.
     */
    type?: 'scroll' | 'dom' | 'content';
    events?: Events<T>;
    props?: DOMElementProps;
};
export declare function element<T extends keyof HTMLElementEventMap>(opts: Options<T>): ViewPlugin<{
    dom?: HTMLElement | undefined;
    view: EditorView;
    destroy(): void;
}>;
/**
 * The DOM element that can be styled to scroll.
 * (Note that it may not have been, so you can't assume this is scrollable.)
 */
export declare function dom<T extends keyof HTMLElementEventMap>(opts: Events<T>): ViewPlugin<{
    dom?: HTMLElement | undefined;
    view: EditorView;
    destroy(): void;
}>;
/**
 * The DOM element that wraps the entire editor view.
 */
export declare function scroll<T extends keyof HTMLElementEventMap>(opts: Events<T>): ViewPlugin<{
    dom?: HTMLElement | undefined;
    view: EditorView;
    destroy(): void;
}>;
/**
 * The editable DOM element holding the editor content.
 * You should not, usually, interact with this content directly though the DOM,
 * since the editor will immediately undo most of the changes you make.
 */
export declare function content<T extends keyof HTMLElementEventMap>(opts: Events<T>): ViewPlugin<{
    dom?: HTMLElement | undefined;
    view: EditorView;
    destroy(): void;
}>;
export {};
